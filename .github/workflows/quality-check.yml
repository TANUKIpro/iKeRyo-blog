name: âœ… è¨˜äº‹å“è³ªãƒã‚§ãƒƒã‚¯

on:
  pull_request:
    paths:
      - 'articles/**/*.md'
    types: [opened, synchronize]

jobs:
  quality-check:
    runs-on: ubuntu-latest
    
    steps:
      - name: ğŸ“¥ ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: ğŸ Pythonç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: ğŸ“¦ ä¾å­˜é–¢ä¿‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
        run: |
          pip install -r requirements.txt
          pip install pyspellchecker language-tool-python
      
      - name: ğŸ” å¤‰æ›´ãƒ•ã‚¡ã‚¤ãƒ«æ¤œå‡º
        id: changed-files
        uses: tj-actions/changed-files@v40
        with:
          files: |
            articles/**/*.md
          separator: "\n"
      
      - name: ğŸ” å“è³ªãƒã‚§ãƒƒã‚¯å®Ÿè¡Œ
        if: steps.changed-files.outputs.any_changed == 'true'
        run: |
          cat > scripts/quality_checker.py << 'EOF'
          import sys
          import re
          import json
          from pathlib import Path
          from typing import Dict, List
          from utils.markdown_parser import MarkdownParser
          from utils.obsidian_processor import ObsidianProcessor
          
          class QualityChecker:
              def __init__(self):
                  self.parser = MarkdownParser()
                  self.processor = ObsidianProcessor('.')
                  self.issues = []
              
              def check_article(self, markdown_file: str) -> Dict:
                  article_data = self.parser.parse_file(markdown_file)
                  content = article_data['content']
                  metadata = article_data['metadata']
                  
                  results = {
                      'file': markdown_file,
                      'checks': {},
                      'statistics': {},
                      'issues': []
                  }
                  
                  # 1. ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãƒã‚§ãƒƒã‚¯
                  results['checks']['metadata'] = self._check_metadata(metadata)
                  
                  # 2. ç”»åƒãƒã‚§ãƒƒã‚¯
                  results['checks']['images'] = self._check_images(content, Path(markdown_file).parent)
                  
                  # 3. ãƒªãƒ³ã‚¯ãƒã‚§ãƒƒã‚¯
                  results['checks']['links'] = self._check_links(content)
                  
                  # 4. è¨˜äº‹çµ±è¨ˆ
                  results['statistics'] = self._calculate_statistics(content)
                  
                  # 5. ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒã‚§ãƒƒã‚¯
                  results['checks']['format'] = self._check_format(content)
                  
                  return results
              
              def _check_metadata(self, metadata: Dict) -> Dict:
                  issues = []
                  
                  # å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãƒã‚§ãƒƒã‚¯
                  required_fields = ['param_category', 'param_tags']
                  for field in required_fields:
                      if field not in metadata or not metadata[field]:
                          issues.append(f"å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ '{field}' ãŒæœªè¨­å®š")
                  
                  # æ—¥ä»˜ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒã‚§ãƒƒã‚¯
                  if 'param_created' in metadata:
                      date_pattern = r'^\d{4}-\d{2}-\d{2}'
                      if not re.match(date_pattern, str(metadata['param_created'])):
                          issues.append("æ—¥ä»˜ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãŒä¸æ­£ï¼ˆYYYY-MM-DDå½¢å¼ã‚’ä½¿ç”¨ï¼‰")
                  
                  return {
                      'passed': len(issues) == 0,
                      'issues': issues
                  }
              
              def _check_images(self, content: str, base_dir: Path) -> Dict:
                  issues = []
                  images = self.processor.extract_images(content, base_dir)
                  
                  for img in images:
                      if not Path(img['local_path']).exists():
                          issues.append(f"ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {img['original_filename']}")
                      
                      # ç”»åƒã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯ï¼ˆ5MBä»¥ä¸Šã¯è­¦å‘Šï¼‰
                      if Path(img['local_path']).exists():
                          size_mb = Path(img['local_path']).stat().st_size / (1024 * 1024)
                          if size_mb > 5:
                              issues.append(f"ç”»åƒã‚µã‚¤ã‚ºãŒå¤§ãã™ãã¾ã™: {img['original_filename']} ({size_mb:.1f}MB)")
                  
                  return {
                      'passed': len(issues) == 0,
                      'issues': issues,
                      'image_count': len(images)
                  }
              
              def _check_links(self, content: str) -> Dict:
                  issues = []
                  
                  # å¤–éƒ¨ãƒªãƒ³ã‚¯ã®æŠ½å‡º
                  url_pattern = r'https?://[^\s\)"]+'
                  urls = re.findall(url_pattern, content)
                  
                  # å†…éƒ¨ãƒªãƒ³ã‚¯ã®æŠ½å‡º
                  wiki_pattern = r'\[\[([^\]|]+)'
                  wiki_links = re.findall(wiki_pattern, content)
                  
                  return {
                      'passed': True,
                      'external_links': len(urls),
                      'internal_links': len(wiki_links),
                      'issues': issues
                  }
              
              def _calculate_statistics(self, content: str) -> Dict:
                  # è¦‹å‡ºã—å‰Šé™¤
                  text_only = re.sub(r'^#+\s+.*$', '', content, flags=re.MULTILINE)
                  # ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯å‰Šé™¤
                  text_only = re.sub(r'```[\s\S]*?```', '', text_only)
                  # ãƒªãƒ³ã‚¯å‰Šé™¤
                  text_only = re.sub(r'\[([^\]]+)\]\([^\)]+\)', r'\1', text_only)
                  
                  # æ–‡å­—æ•°è¨ˆç®—
                  char_count = len(text_only)
                  # å˜èªæ•°è¨ˆç®—ï¼ˆæ—¥æœ¬èªè€ƒæ…®ï¼‰
                  word_count = len(re.findall(r'\w+|[^\x00-\x7F]+', text_only))
                  # èª­äº†æ™‚é–“ï¼ˆ400æ–‡å­—/åˆ†ã¨ã—ã¦è¨ˆç®—ï¼‰
                  reading_time = max(1, round(char_count / 400))
                  
                  return {
                      'character_count': char_count,
                      'word_count': word_count,
                      'reading_time_minutes': reading_time
                  }
              
              def _check_format(self, content: str) -> Dict:
                  issues = []
                  
                  # è¦‹å‡ºã—ãƒ¬ãƒ™ãƒ«ãƒã‚§ãƒƒã‚¯
                  headings = re.findall(r'^(#+)\s+', content, flags=re.MULTILINE)
                  if headings and headings[0] != '#':
                      issues.append("æœ€åˆã®è¦‹å‡ºã—ã¯H1ï¼ˆ#ï¼‰ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„")
                  
                  # é€£ç¶šç©ºè¡Œãƒã‚§ãƒƒã‚¯
                  if '\n\n\n' in content:
                      issues.append("3è¡Œä»¥ä¸Šã®é€£ç¶šç©ºè¡ŒãŒã‚ã‚Šã¾ã™")
                  
                  return {
                      'passed': len(issues) == 0,
                      'issues': issues
                  }
          
          if __name__ == "__main__":
              checker = QualityChecker()
              results = []
              
              for file in sys.argv[1:]:
                  if Path(file).exists():
                      result = checker.check_article(file)
                      results.append(result)
              
              # çµæœã‚’ä¿å­˜
              with open('quality_report.json', 'w', encoding='utf-8') as f:
                  json.dump(results, f, ensure_ascii=False, indent=2)
          EOF
          
          # ãƒã‚§ãƒƒã‚¯å®Ÿè¡Œ
          python scripts/quality_checker.py ${{ steps.changed-files.outputs.all_changed_files }}
      
      - name: ğŸ“Š å“è³ªãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
        if: steps.changed-files.outputs.any_changed == 'true'
        run: |
          echo "## âœ… è¨˜äº‹å“è³ªãƒã‚§ãƒƒã‚¯çµæœ" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -f quality_report.json ]; then
            cat quality_report.json | jq -r '.[] | 
              "### ğŸ“„ " + (.file | split("/") | last) + "\n" +
              "#### ğŸ“Š çµ±è¨ˆæƒ…å ±\n" +
              "- æ–‡å­—æ•°: " + (.statistics.character_count | tostring) + "\n" +
              "- æ¨å®šèª­äº†æ™‚é–“: " + (.statistics.reading_time_minutes | tostring) + "åˆ†\n" +
              "- ç”»åƒæ•°: " + (.checks.images.image_count | tostring) + "\n" +
              "- å¤–éƒ¨ãƒªãƒ³ã‚¯: " + (.checks.links.external_links | tostring) + "\n\n" +
              "#### ğŸ” ãƒã‚§ãƒƒã‚¯çµæœ\n" +
              (if .checks.metadata.passed then "âœ… ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿: OK" else "âŒ ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿: " + (.checks.metadata.issues | join(", ")) end) + "\n" +
              (if .checks.images.passed then "âœ… ç”»åƒ: OK" else "âŒ ç”»åƒ: " + (.checks.images.issues | join(", ")) end) + "\n" +
              (if .checks.format.passed then "âœ… ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ: OK" else "âŒ ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ: " + (.checks.format.issues | join(", ")) end) + "\n"
            ' >> $GITHUB_STEP_SUMMARY
          fi
      
      - name: ğŸ’¬ PRã‚³ãƒ¡ãƒ³ãƒˆã§çµæœå…±æœ‰
        if: steps.changed-files.outputs.any_changed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            if (!fs.existsSync('quality_report.json')) return;
            
            const report = JSON.parse(fs.readFileSync('quality_report.json', 'utf8'));
            let comment = '## âœ… è¨˜äº‹å“è³ªãƒã‚§ãƒƒã‚¯çµæœ\n\n';
            
            let hasIssues = false;
            
            for (const result of report) {
              const filename = result.file.split('/').pop();
              comment += `### ğŸ“„ ${filename}\n\n`;
              
              // çµ±è¨ˆæƒ…å ±
              comment += `ğŸ“Š **çµ±è¨ˆ:** ${result.statistics.character_count}æ–‡å­— / èª­äº†${result.statistics.reading_time_minutes}åˆ†\n\n`;
              
              // å•é¡ŒãŒã‚ã‚Œã°è¡¨ç¤º
              const allChecks = Object.values(result.checks);
              const failedChecks = allChecks.filter(check => !check.passed);
              
              if (failedChecks.length > 0) {
                hasIssues = true;
                comment += 'âš ï¸ **æ”¹å–„ãŒå¿…è¦ãªé …ç›®:**\n';
                for (const check of failedChecks) {
                  for (const issue of check.issues) {
                    comment += `- ${issue}\n`;
                  }
                }
              } else {
                comment += 'âœ… ã™ã¹ã¦ã®ãƒã‚§ãƒƒã‚¯ã«åˆæ ¼ã—ã¾ã—ãŸï¼\n';
              }
              
              comment += '\n';
            }
            
            if (hasIssues) {
              comment += '> ğŸ’¡ ä¸Šè¨˜ã®é …ç›®ã‚’ç¢ºèªã—ã€å¿…è¦ã«å¿œã˜ã¦ä¿®æ­£ã—ã¦ãã ã•ã„ã€‚';
            }
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });